# program:     AmpliconDB_manual_annotation.sh
# author:      Gloria Rendon
# date:        August, 2016
# description: a program that takes six parameters  and generates a database of amplicons in fasta and in tsv formats. 
# The OUTPUT fasta sequences include taxonomic information
# param1: redofile is a file in tabular format with sequences missing taxonomic information, this file is generated by prepareAmpliconDB_w_taxid_batch.sh
# param2: ingenbank is a file in genbank format to be used as the source of the taxonomic information to be added to the outputfiles
# param3: indatabase.fa is the database in fasta format that has a few records with missing taxonomic information,  this file is generated by prepareAmpliconDB_w_taxid_batch.sh
# param4: indatabase.tsv is the database in tabular format that also needs updating, this file is generated by prepareAmpliconDB_w_taxid_batch.sh
# param5: outdatabase.fa is the name of the updated database in fasta format
# param6: outdatabase.tsv is the name of the updated database in tabular format            
#########################################################################################

########################
# define global variables, hashes and filenames
########################

%TSV=();
%MISSING=();

$ingenbank="";
$infastadb="";
$intabledb="";
$outfastadb="";
$outtabledb="";
$redotable="";

########################
# reading input from stdin and sanity check
########################

if ($#ARGV<5) {
	print "script that parses genbank records and extracts accession, organism, and taxid.\n";
	print "then uses that information to UPDATE records in the database files\n";
	print "EXAMPLE: $0 <redotable> <infile.gb> <indatabase.fa> <indatabase.tsv> <outdatabase.fa> <outdatabase.tsv>\n\n";
	print "Where redotable indatabase.fa and indatabase.tsv are output files of running the script prepareAmpliconDB_w_taxid_batch.sh\n\n\n";
	exit 0;
}

$redotable=shift;
$ingenbank=shift;
$infastadb=shift;
$intabledb=shift;
$outfastadb=shift;
$outtabledb=shift;

die("Required parameter: redotable \n")       if $redotable eq "";
die("Required parameter: infile.gb \n")       if $ingenbank eq "";
die("Required parameter: indatabase.fa \n")   if $infastadb eq "";
die("Required parameter: indatabase.tsv \n")  if $intabledb eq "";
die("Required parameter: outdatabase.fa \n")  if $outfastadb eq "";
die("Required parameter: outdatabase.tsv \n") if $outtabledb eq "";


open(OUTFASTADB,">$outfastadb")  || die("Cannot open $outfastadb \n");
open(OUTTABLEDB,">$outtabledb")  || die("Cannot open $outtabledb \n");


########################
# hashing redotable with the sequences missing taxonomic information
# redotable is a tab delimited file with columns in this order
# col0=SEQIDnnnn  where nnnn start at 1, this string is the unique identifier that we use internally for this sequence	
# col1=accession
########################


print "processing $redotable...\n\n";
$count=0;
open(REDOTABLE,"<$redotable") || die("Cannot open $redotable \n");
while ( my $redoline = <REDOTABLE> ) {
	chomp $redoline;
	$redoline =~ s/\r\n//g;
        my @redodet=split(/\t/,$redoline);
        print "hashing seqid=$redodet[0] accession=$redodet[1]\n";
        if ( ! defined $MISSING{$redodet[1]} ) { 
        	print "new accession-seq pair\n";
        	$MISSING{$redodet[1]}=$redodet[0];
        } else { 
        	# there could be colisions: one accession and two or more seqids
        	$newvalue=$MISSING{$redodet[1]};
        	$newvalue=$newvalue."\t".$redodet[0];
        	print "existing accession, new value for seqids=$newvalue\n";
        	$MISSING{$redodet[1]}=$newvalue;  
        }
        $count++;
}
close(REDOTABLE);
print "done reading $redotable table of sequences missing taxonomic information\t$count records read\n";
sleep(15);


########################
# hashing master table with meta level info for the sequences, 
# intabledb is a tab delimited file with columns in this order
# col0=SEQIDnnnn  where nnnn start at 1, this string is the unique identifier that we use internally for this sequence	
# col1=string that starts with taxid_xxxxxx_gi_yyyyyyy_accessionInfo_SpeciesScientificName when the taxid information is complete
# col1=string that starts with manualAnnot when the taxid information is missing    
# col2=list of file names containing this sequence
########################



print "processing $intabledb...\n\n";
$count=0;
open(IDTABLE,"<$intabledb") || die("Cannot open $intabledb \n");
while ( my $line = <IDTABLE> ) {
	chomp $line;
	$line =~ s/\r\n//g;
        my @det=split(/\t/,$line);
        $TSV{$det[0]}{"SEQ"}=$det[1];
        $TSV{$det[0]}{"FILES"} = $det[2];
        $count++;        
}
close(IDTABLE);
print "done reading $intabledb table of metalevel info about the database of fasta sequences\t$count records read\n";
sleep(5);


########################
# hashing the genbank file to parse accession, gi, taxonomic identifier and scientific name for each record
# the user must use a url such as NCBI BATCH ENTREZ http://www.ncbi.nlm.nih.gov/sites/batchentrez
# to retrieve the genbank records of a list of accession numbers that the user provided in a file
# the user can easily make the list of accession numbers from the second column of the redotable
########################

print "processing genbank file $ingenbank\n\n";
$count=0;
local $/ = "\n\/\/\n";   # this is the record delimiter for genbank records
open(GB,"<$ingenbank");

while ( $gbrec = <GB> ) {

	#print "parsing $gb\n\n";
	
	$accid="";  #variable for accession
	$ginum="";  #variable for gi number
	$sciname=""; #variable for scientific name of the species
	$taxid="";  #variable for taxid
	
	if ( $gbrec =~ /VERSION     (.*)GI:(.*)\n/ ) { $accid=$1; $ginum=$2}
	if ( $gbrec =~ /ORGANISM  (.*)\n/ )    { $sciname=$1 }
	if ( $gbrec =~ /taxon:(.*)\"\n/  )    { $taxid=$1; }

	print "\nparsed genbank record accession=$accid gi=$ginum taxid=$taxid species_name=$sciname\n";
	
        $sciname=~ s/ /_/g;
        $accid=~ s/ //g;
        $taxid=~ s/ //g;
        $ginum=~ s/ //g;

	# new seqid old seqid
	
        $newExtendedSeqid="taxid_".$taxid."_gi\|".$ginum."\|gb\|".$accid."_".$sciname;
        $originalSeqid=$MISSING{$accid};

	# check that the hash has a single seqid for that accession
	
	if ( $originalSeqid !~ /\t/ ) {
		# only one seqid for this accession. update record 
		print "one accession-seq pair. updating record for seqid=$originalSeqid value=$newExtendedSeqid";
		$TSV{$originalSeqid}{"SEQ"}=$newExtendedSeqid;
	} else {
		# more than one seqid for this accession. update record in a loop
		@allseqids=split(/\t/,$originalSeqid);
		print "several seqids to update for this accession, $originalSeqid\n";
		foreach $seqid ( @allseqids ) { 
			print "updating record for seqid=$seqid value=$newExtendedSeqid";
			$TSV{$seqid}{"SEQ"}=$newExtendedSeqid; 
		}	
	}
        $count++;
}

close(GB);
print "done reading $ingenbank genbank file with  taxonomic information \t$count records read\n";
sleep(10);


########################
# UPDATING DATABASES
########################


print "UPDATING $infastadb results will be written to $outfastadb\n\n";
print "UPDATING $intabledb results will be written to $outtabledb\n\n";

$count=0;
$updates=0;
$notfound=0;
local $/ = ">";  # this is the new record delimiter for fasta records
open(INFA,"<$infastadb") || die("Cannot open $infastadb \n");
while (<INFA>) {
	$seq_all = $_;
	$seq_all =~ s/>//;           # to correct the parsing result by removing > from the end of the record
	$seq_all = ">".$seq_all;     # to correct the parsing result by prepending > to the record

	#print "processing $seq_all";
	$count++;
	if ( $seq_all =~ m/>(.*)_taxid_(.*)\n((.|\n)*)/ ) {
		# this record is compete. nothing needs to be done
		$seqid =$1;
		$newcol2=$TSV{$seqid}{"SEQ"};
		$newcol3=$TSV{$seqid}{"FILES"};
		print OUTTABLEDB "$seqid\t$newcol2\t$newcol3\n";
		print OUTFASTADB "$seq_all";		
	} elsif ( $seq_all =~ m/>(.*)_manualAnnot_(.*)\n((.|\n)*)/ ) {
		# this record needs updated info
		$seqid =$1;
		$defline=$2;
		$seqBody=$3;
		$defline="_manualAnnot_".$defline;		
		print "Updating. SEQID=$seqid defline=$defline\n";
		if ( defined $TSV{$seqid} ) {
			# let's update the database files			
			$newcol2=$TSV{$seqid}{"SEQ"};
			$newcol3=$TSV{$seqid}{"FILES"};
			$newheader=">".$seqid."_".$newcol2;
			print "newdefline=$seqid\t$newcol2\t$newcol3\n";
			print OUTTABLEDB "$seqid\t$newcol2\t$newcol3\n";
			print OUTFASTADB "$newheader\n$seqBody";			
			$updates++;
		} else {
			print "could not find $seqid in hash for record=\[$count\]. \n";
			$notfound++;
		}
	} else {
		print "could not parse line for record=\[$count\]. Next\n";
	}
}
close(INFA);
close(OUTFASTADB);
close(OUTTABLEDB);
%TSV=();
%MISSING=();
print "done UPDATING databases. $count records read $updates records updated $notfound records not found\n\nDOne Exiting now\n\n\n";
