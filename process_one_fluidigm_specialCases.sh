#!/bin/sh
# program:     process_one_fluidigm_specialCases.sh
# author:      Gloria Rendon
# date:        April, 2017
# description: a program that takes as input files of fluidigm-demultiplexed paired reads generated by pipeline version 2
#              and runs: trim, stitch, fastq_to_fasta to get them ready for vsearch
#########################################################################################

set -x

set +x;
echo -e "\n\n##############################################################################">&2;  
echo -e "\n\n############          START process_one_fluidigm.sh            ###############">&2;
echo -e "\n\n##############################################################################" >&2; 
set -x; 

demultiplexed=$1
R1=$2
R2=$3
outputfile=$4
ReportEmptyFiles=$5
outputdir=$6
runfile=$7


if [ $# != 7 ]
then
     echo -e "Program $0 stopped at line $LINENO\nREASON=Parameters mismatch. \n\n"
     echo -e "Rerun this program like this:\n$0 <amplicon-sample prefix><read1><read2><outputfile><reporemptyfiles><outputdir><configuration file>\n\n"
     exit 1;
fi

if [ ! -s $runfile ]
then
     echo "$runfile configuration file not found. Exiting now\n\n"
     exit 1;
fi


set +x;
echo -e "\n\n##############################################################################">&2;  
echo -e "\n\n############   PARSING CONFIGURATION FILE AND SANITY CHECK     ###############">&2;
echo -e "\n\n##############################################################################" >&2; 
set -x; 

threads=$( cat $runfile | grep -w THREADS | cut -d '=' -f2 )
trimMod=$( cat $runfile | grep -w TRIMMOMATICMOD | cut -d '=' -f2 )
fastqcMod=$( cat $runfile | grep -w FASTQCMOD | cut -d '=' -f2 )
pearMod=$( cat $runfile | grep -w PEARMOD | cut -d '=' -f2 )
fastxMod=$( cat $runfile | grep -w FASTXMOD | cut -d '=' -f2 )
adapters=$( cat $runfile | grep -w TRIMMOMATICADAPTERS | cut -d '=' -f2 )
cleanup=$( cat $runfile | grep -w REMOVE_TMPFILES | cut -d '=' -f2 | tr '[a-z]' '[A-Z]' )

trimCase=$( cat $runfile | grep "PREPREADS_CASE" | cut -d "=" -f2 )
readlen=$( cat $runfile | grep "READ_LENGTH" | cut -d "=" -f2 )
minlen=$( cat $runfile | grep "MIN_LEN" | cut -d "=" -f2 )
maxlenone=$( cat $runfile | grep "MAX_LEN_SINGLE" | cut -d "=" -f2 )
maxlenpair=$( cat $runfile | grep "MAX_LEN_STITCHED" | cut -d "=" -f2 )
minOverlap=$( cat $runfile | grep "MIN_OVERLAP" | cut -d "=" -f2 )
headcrop=$( cat $runfile | grep "HEADCROP" | cut -d "=" -f2 )
trimdefaultargs1=" ILLUMINACLIP:$adapters:1:20:10 "
trimdefaultargs2=" LEADING:3 TRAILING:3 SLIDINGWINDOW:3:15 "


if [ `expr ${#readlen}` -lt 1 ]
then
	echo -e "READ_LENGTH has no value. Exit now"
	exit 1
fi

if [ $readlen -eq $readlen 2>/dev/null ]
then
	echo value for READ_LENGTH is a valid number
else
	echo value for READ_LENGTH is not a number. exiting now
	exit 1;
fi


defaultminlen=$( echo "$readlen * 75 / 100" | bc -l | cut -d '.' -f1 ) #hack to cast float to int


if [ ! -s $adapters ]
then
	echo -e "TRIMMOMATICADAPTERS file not found. Exit now"
	exit 1
fi


if [ `expr ${#trimCase}` -lt 1 ]
then
	echo -e "PREPREADS_CASE has no value. Exit now"
	exit 1
fi

if [ $trimCase -lt 1 -o  $trimCase -gt 3 ]
then
	echo value for PREPREADS_CASE is invalid. Exit now
	exit 1
fi

set +x;
echo -e "\n##############################################################################"  
echo -e "\n############   put together the options of the commands      #################"
echo -e "\n############   trimCase=1 no stitching                       #################"
echo -e "\n############   trimCase=2 extreme overlap                    #################"
echo -e "\n############   trimCase=3 normal overlap                     #################"
echo -e "\n##############################################################################" >&2; set -x; 




if [ $trimCase -eq 1 ]
then
	minOverlap=0
fi

if [ $trimCase -eq 2 -a `expr ${#minOverlap}` -lt 1 ]
then
	minOverlap=50
fi

if [ $trimCase -eq 3 -a `expr ${#minOverlap}` -lt 1 ]
then
	minOverlap=20
fi

stitchargs=" -j $threads -v $minOverlap "
trimargs=$trimdefaultargs1

# first we check if we need to perform hard-trim

if [ `expr ${#headcrop}` -gt 1 ]
then
	arg1=" HEADCROP:$headcrop "
	trimargs=${trimargs}${arg1}
fi

if [ `expr ${#maxlenpair}` -gt 1 ]
then
	arg2=" -m $maxlenpair "
	stitchargs=${stitchargs}$arg2	
fi

if [ `expr ${#maxlenone}` -gt 1 ]
then
	arg3=" CROP:$maxlenone "
	trimargs=${trimargs}$arg3	
fi


# then we add parameters for soft-clipping

trimargs=${trimargs}$trimdefaultargs2

if [ `expr ${#minlen}` -gt 1 ]
then
	arg4=" MINLEN:$minlen "
	arg5=" -n $minlen "
	trimargs=${trimargs}$arg4
	stitchargs=${stitchargs}$arg5	
else 
	arg4=" MINLEN:$defaultminlen "
	arg5=" -n $defaultminlen "	
	trimargs=${trimargs}$arg4
	stitchargs=${stitchargs}$arg5
fi


set +x; echo -e "\n\n\n############ Prep work: create folders for FastQC results\n\n" >&2; set -x;

fqdir2=$outputdir/FastQC-trimmed
fqdir1=$outputdir/FastQC-raw               
mkdir -p $fqdir1
mkdir -p $fqdir2     

set +x; echo -e "\n\n\n############ Prep work: declare variables and output filename\n\n" >&2; set -x;

b1=${demultiplexed}_R1
b2=${demultiplexed}_R2
pairedR1=${b1}.paired.fq
pairedR2=${b2}.paired.fq
unpairedR1=${b1}.unpaired.fq
unpairedR2=${b2}.unpaired.fq
stitched=${demultiplexed}_stitched
merged=${demultiplexed}_stitchedMerged


set +x; echo -e "\n\n\n############ STEP1 fastqc on raw reads $R1 $R2\n\n" >&2; set -x;

cd $outputdir

echo `date`
module load $fastqcMod
fastqc -o $fqdir1 -t $threads $R1 $R2
module purge
echo `date`

set +x; echo -e "\n\n\n############ STEP2 trim raw reads $R1 $R2\n\n" >&2; set -x;

echo `date`
module load $trimMod          

java -classpath /home/apps/trimmomatic/trimmomatic-0.33/trimmomatic-0.33.jar \
org.usadellab.trimmomatic.TrimmomaticPE \
-threads $threads \
-phred33 \
-trimlog $outputdir/${demultiplexed}.trim.log \
$R1 $R2 \
$pairedR1 $unpairedR1 \
$pairedR2 $unpairedR2 \
$trimargs 
   
exitcode=$?
          
if [ $exitcode -ne 0 ]
then
   echo program stopped at line=$LINENO reason=trimmomatic failed on raw reads $R1 $R2
   exit $exitcode
fi
  
if [ ! -s $pairedR1 -a ! -s $pairedR2 ]
then
   echo empty files of trimmed reads $pairedR1 $pairedR2. stop analysis here
   exit 0
fi

module purge
echo `date` 

set +x; echo -e "\n\n\n############ STEP3 fastqc on trimmed reads $pairedR1 $pairedR2\n\n" >&2; set -x;

echo `date` 
module load $fastqcMod
           

fastqc -o $fqdir2 -t $threads $pairedR1 $pairedR2
            
module purge
echo `date`

if [ $trimCase -eq 1 ]
then
	set +x; echo -e "\n\n\n############ STEP4 convert fastq to fasta \n\n" >&2; set -x;
	echo `date`
	module load $fastxMod

	fastq_to_fasta -v -i $pairedR1 -o $outputfile

	exitcode=$?

	if [ $exitcode -ne 0 ]
	then
		echo program stopped at line=$LINENO reason=convert fastq to fasta failed on  $outputfile
		exit $exitcode
	fi

	module purge
	
else

	set +x; echo -e "\n\n\n############ STEP4 stitch trimmed reads $pairedR1 $pairedR2\n\n" >&2; set -x;

	echo `date`
	module load $pearMod

	pear $stitchargs -f $pairedR1 -r $pairedR2 -o $stitched

	exitcode=$?

	if [ $exitcode -ne 0 ]
	then
	   echo program stopped at line=$LINENO reason=stitch cmd failed on trimmed reads on $pairedR1 $pairedR2
	   exit $exitcode
	fi

	module purge
	echo `date`

	set +x; echo -e "\n\n\n############ STEP5 convert fastq to fasta $merged \n\n" >&2; set -x;

	echo `date`
	module load $fastxMod

	if [ -s ${stitched}.assembled.fastq ]
	then
		fastq_to_fasta -v -i ${stitched}.assembled.fastq -o ${stitched}.assembled.fasta
		fastq_to_fasta -v -i ${stitched}.unassembled.forward.fastq -o ${stitched}.unassembled.forward.fasta          
		cat ${stitched}.assembled.fasta ${stitched}.unassembled.forward.fasta > $outputfile
	else
		fastq_to_fasta -v -i ${stitched}.unassembled.forward.fastq -o ${stitched}.unassembled.forward.fasta          
		cp ${stitched}.unassembled.forward.fasta  $outputfile	
	fi
	
	module purge
fi


echo `date`

set +x; echo -e "\n\n\n############ STEP6 QC and cleanup $outputdir \n\n" >&2; set -x;

if [ ! -s $outputfile ]
then
	set +x; echo -e "\n\n\n############ WARNING $outputfile is empty \n\n" >&2; set -x;
	echo $outputfile >> $emptyOut
elif [ $cleanup == "YES" ]
then
	set +x; echo -e "\n\n\n############ everything is ok, cleanup temp files\n\n" >&2; set -x;
	rm ${demultiplexed}*paired.fq 
	rm ${demultiplexed}*stitched*
	rm ${demultiplexed}.trim.log  
fi

echo `date`
set +x; echo -e "\n\n\n############ Done. Outputfile=$outputfile  Outputdir=$outputdir \n\n\n" >&2; set -x;

set +x;
echo -e "\n\n##############################################################################">&2;  
echo -e "\n\n############          END process_one_fluidigm.sh            ###############">&2;
echo -e "\n\n##############################################################################" >&2; 
set -x; 
