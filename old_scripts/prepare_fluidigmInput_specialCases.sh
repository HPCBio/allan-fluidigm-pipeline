#!/bin/sh
# program:     prepare_fluidigmInput_specialCases.sh
# author:      Gloria Rendon
# date:        August, 2016
# description: a program that takes as input files of fluidigm-demultiplexed paired reads generated by pipeline version 2
#              and runs: trim, stitch, fastq_to_fasta to get them ready for vsearch
#########################################################################################

set -x
echo `date`

set +x;
echo -e "\n\n##############################################################################" >&2;
echo -e "\n############   STARTS prepare_fluidigmInput_specialCases.sh            #########" >&2;
echo -e "\n##############################################################################\n\n" >&2; 
set -x;

if [ $# != 1 ]
then
     echo -e "\nprogram $0 takes as input files of fluidigm-demultiplexed paired reads generated by pipeline version 2\n"
     echo -e "and spawns qsub jobs that: trim, stitch, fastq_to_fasta those files to get them ready for vsearch\n\n"
     echo -e "Program $0 stopped at line $LINENO\nREASON=Parameters mismatch. \n\n"
     echo -e "Rerun this program like this:\n$0 <configuration file>\n"
     echo -e "Where <configuration file> is a text file with information needed to run this program\n\n";
     exit 1;
fi

runfile=$1

if [ ! -s $runfile ]
then
     echo "$runfile configuration file not found. Exiting now\n\n"
     exit 1;
fi


set +x;
echo -e "\n\n##############################################################################">&2;  
echo -e "\n\n############   PARSING CONFIGURATION FILE AND SANITY CHECK     ###############">&2;
echo -e "\n\n##############################################################################" >&2; 
set -x; 

infiles=$( cat $runfile | grep "INPUTFILES" | cut -d "=" -f2 )                 #raw reads to process
samplefile=$( cat $runfile | grep "SAMPLEFILE" | cut -d "=" -f2 )              #one samplename per line
barcodefile=$( cat $runfile | grep "BARCODEFILE" | cut -d "=" -f2 )            #one barcodename per line
generateInput=$( cat $runfile | grep "GENERATE_INPUTS" | cut -d "=" -f2 | tr '[a-z]' '[A-Z]' )
email=$( cat $runfile | grep -w EMAIL | cut -d '=' -f2 )
rootdir=$( cat $runfile | grep -w PROJECTDIR | cut -d '=' -f2 )
inputdir=$( cat $runfile | grep -w  RAW_READS_DIR | cut -d '=' -f2 )
tmpdir=$( cat $runfile | grep -w TEMPDIR | cut -d '=' -f2 )
outdir=$( cat $runfile | grep -w PREPARED_READS_DIR | cut -d '=' -f2 )
scriptdir=$( cat $runfile | grep -w SCRIPTDIR | cut -d '=' -f2 )
nodes=$( cat $runfile | grep -w NODES | cut -d '=' -f2 )
threads=$( cat $runfile | grep -w THREADS | cut -d '=' -f2 )
queue=$( cat $runfile | grep -w QUEUE_TRIM | cut -d '=' -f2 )
mem=$( cat $runfile | grep -w MEMORY | cut -d '=' -f2 )
trimMod=$( cat $runfile | grep -w TRIMMOMATICMOD | cut -d '=' -f2 )
fastqcMod=$( cat $runfile | grep -w FASTQCMOD | cut -d '=' -f2 )
pearMod=$( cat $runfile | grep -w PEARMOD | cut -d '=' -f2 )
fastxMod=$( cat $runfile | grep -w FASTXMOD | cut -d '=' -f2 )
adapters=$( cat $runfile | grep -w TRIMMOMATICADAPTERS | cut -d '=' -f2 )
JobSizeLimit=$( cat $runfile | grep -w JOBSIZELIMIT | cut -d '=' -f2 )

#sleep 5

set +x; echo -e "\n\n\n############  checking that project folder exists  \n" >&2; set -x;

if [ ! -d $rootdir ]
then
    echo -e "$0 stopped at line $LINENO\sREASON=$rootdir directory not found"
    exit 1;
fi

set +x; echo -e "\n\n\n############  checking that output folder exists  \n" >&2; set -x;

if [ ! -d $outdir ]
then
    echo -e "creating output folder $outdir";
    `mkdir -p $outdir`
fi

set +x; echo -e "\n\n\n############  checking that tmp folder exists  \n" >&2; set -x;

if [ ! -d $tmpdir ]
then
    echo -e "creating output folder $tmpdir";
    `mkdir $tmpdir`
fi

set +x; echo -e "\n\n\n############  checking that input folder exists  \n" >&2; set -x;

if [ ! -d $inputdir ]
then
    echo -e "$0 stopped at line $LINENO\nREASON=inputdir directory not found. Exiting now."
    exit 1;
fi

set +x; echo -e "\n\n\n############ checking that the file with barcode names  exists\n" >&2; set -x;

if [ `expr ${#barcodefile}` -lt 1 ]
then
    echo -e "$0 stopped at line $LINENO\nREASON=file with barcode names was not specified"
    exit 1;
elif [ ! -s $barcodefile  ]
then 
    echo -e "$0 WARNING at line $LINENO\sREASON=$barcodefile barcode file not found or it is empty"
    exit 1;
fi

set +x; echo -e "\n\n\n############  checking that the file with sample names  exists\n" >&2; set -x;

if [ `expr ${#samplefile}` -lt 1 ]
then
    echo -e "$0 stopped at line $LINENO\nREASON=file with sample names was not specified"
    exit 1;
elif [ ! -s $samplefile ]
then 
    echo -e "$0 WARNING at line $LINENO\sREASON=$samplefile sample file not found or it is empty"
    exit 1;
fi

set +x; echo -e "\n\n\n############  checking that the file with raw reads  exists\n" >&2; set -x;

if [ `expr ${#infiles}` -lt 1 ]
then
    echo -e "$0 stopped at line $LINENO\nREASON=file with raw reads was not specified"
    exit 1;
fi

set +x; echo -e "\n\n\n############  checking the value for jobsizelimit\n" >&2; set -x;

if [ `expr ${#JobSizeLimit}` -lt 1 ]
then
    echo -e "$0 WARNING at line $LINENO\nREASON= no value set for JOBSIZELIMIT. Set default value."
    JobSizeLimit=25
fi


set +x;
echo -e "\n##############################################################################"  
echo -e "\n############   PREP WORK. Define more variables and reset files ##############"
echo -e "\n##############################################################################"  
set -x;

listSamples=$( cat $samplefile )            # to verify info with $infiles
listBarcodes=$( cat $barcodefile )          # to verufy info with $infiles
numfilesprocessed=0                         # to count the number of files processed
JobCounter=1                                # to count the number of jobs generated
skipped=$outdir/input_files_with_no_reads   # to count the number of files no processed
emptyOut=$outdir/output_files_with_no_reads # to count the number of empty files
truncate -s 0 $skipped
truncate -s 0 $emptyOut
JobFile=$tmpdir/JobFile.prepareReads.batch$JobCounter  # the file with commands to process files
truncate -s 0 $JobFile

set +x;
echo -e "\n\n##############################################################################">&2;  
echo -e "\n\n############   ANALYSIS BLOCK STARTS HERE                      ###############">&2;
echo -e "\n\n##############################################################################" >&2; 
set -x; 

set +x;
echo -e "\n\n##############################################################################">&2;  
echo -e "\n\n############   GENERATE INPUTFILE                              ###############">&2;
echo -e "\n\n##############################################################################" >&2; 
set -x; 

truncate -s 0 $infiles

$scriptdir/preprocess_reads_specialCases.sh $runfile

if [ ! -s $infiles ]
then 
    echo -e "preprocess_reads_specialCases.sh failed to generate $infiles"
    exit 1;
fi


set +x;
echo -e "\n\n##############################################################################">&2;  
echo -e "\n\n############   START LOOP OVER INPUTFILES                      ###############">&2;
echo -e "\n\n##############################################################################" >&2; 
set -x; 

##################################################################################################
############   INPUTFILES, is a text file. One sample per row, columns are separated by <SPACE>
############   col1=sample col2=barcode col3-read1 col4=read2
############   regexpr for read names: $sample-$barcode_<sequencingindex>_R{1,2}.fastq
##################################################################################################


while read inputline
do

	set +x; echo -e "\n\n\n############  Start processing line=$inputline " >&2; set -x;

	if [ `expr ${#inputline}` -lt 1 ]
	then
		set +x; echo -e "\n\n\n############  SKIP empty line " >&2; set -x;
		continue
	fi

	set +x; echo -e "\n\n\n############  Parsing line=$inputline " >&2; set -x;

	sample=$( echo $inputline | cut -d ' ' -f1 )
	barcode=$( echo $inputline | cut -d ' ' -f2 )
	R1=$( echo $inputline | cut -d ' ' -f3 )
	R2=$( echo $inputline | cut -d ' ' -f4 )
	demultiplexed=${sample}-${barcode}
	outputfile=${demultiplexed}_SearchReady.fasta
	outputdir=$outdir/$sample/${demultiplexed}
	emptyRead="NO"
	emptySample="NO"
	emptyBarcode="NO"
	thesample=$( grep "$sample" $samplefile )
	thebarcode=$( grep "$barcode" $barcodefile )

	set +x;
	echo -e "\n##############################################################################" 
	echo -e "\n########## Validation: This line will be skipped if any validation test fails" 
	echo -e "\n##############################################################################" >&2; set -x;

	if [ ! -s $R1 ]
	then
	    echo -e "empty file read1 $R1"
	    emptyRead="YES";
	fi

	if [ ! -s $R2 ]
	then
	    echo -e "empty file read2 $R2"
	    emptyRead="YES";
	fi

	if [ `expr ${#thesample}` -lt 1 ] 
	then
	    echo -e "sample=$sample not found in samplefile $samplefile"
	    emptySample="YES";
	fi

	if [ `expr ${#thebarcode}` -lt 1 ] 
	then
	    echo -e "barcode=$barcode not found in barcodefile $barcodefile"
	    emptyBarcode="YES";
	fi


	if [ $emptyRead != "NO" -a $emptyBarcode != "NO" -a $emptySample != "NO" ]
	then
		set +x;
		echo -e "\n##############################################################################" 
		echo -e "\n######### Validation failed. Skipping this line   $inputline"
		echo -e "\n##############################################################################" >&2; set -x;             

		echo -e "$inputline\n" >> $skipped
		continue
	fi

	if [ -d $outputdir ]
	then
		echo outputdir=$outputdir is not empty. Reset it
		rm -rf $outputdir
	fi

	set +x;
	echo -e "\n##############################################################################" 
	echo -e "\n############ info validated. proceed with analysis             ###############"    
	echo -e "\n############ Prepare_reads will be done in batches             ###############"
	echo -e "\n############ Next block of code is to populate the batches     ###############"
	echo -e "\n##############################################################################" >&2; set -x; 


	(( numfilesprocessed++ ))


	set +x;
	echo -e "\n##############################################################################" 
	echo -e "\n############ now checking that the batch limit has not been rached ###########" 
	echo -e "\n##############################################################################" >&2; set -x;

	if [ $numfilesprocessed -gt $JobSizeLimit ]
	then

		set +x; echo -e "\n\n\n###### file limit has been reached for this batch. Sechedule this jobfile \n" >&2; set -x;

		qsub1=$tmpdir/qsub.prepareReads.$JobCounter
		echo "#PBS -S /bin/bash" > $qsub1
		echo "#PBS -N prepareReads_$JobCounter" >> $qsub1
		echo "#PBS -M $email" >> $qsub1
		echo "#PBS -m ae" >> $qsub1
		echo "#PBS -e $tmpdir/qsub.prepareReads_$JobCounter.er" >> $qsub1
		echo "#PBS -o $tmpdir/qsub.prepareReads_$JobCounter.ou" >> $qsub1
		echo "#PBS -l nodes=$nodes:ppn=$threads" >> $qsub1
		echo "#PBS -q $queue" >> $qsub1
		echo "#PBS -l nodes=$nodes:ppn=$threads" >> $qsub1
		echo "echo begin execution at \`date\`" >> $qsub1			
		cat $JobFile >> $qsub1
		echo "echo end   execution at \`date\`" >> $qsub1
		`chmod g+r $qsub1 `
		jobid=`qsub $qsub1`
		echo `date`

		set +x; echo -e "\n\n\n############ file limit has been reached for this batch. initialize jobfile for the next batch  \n" >&2; set -x;
		numfilesprocessed=1		
		(( JobCounter++ ))		
		JobFile=$tmpdir/JobFile.prepareReads.$JobCounter
		truncate -s 0 $JobFile

		echo "$scriptdir/process_one_fluidigm_specialCases.sh $demultiplexed $R1 $R2 $outputfile $emptyOut $outputdir $runfile" >> $JobFile

	else

		set +x; echo -e "\n\n\n############ file limit has not been reached for this batch. Add command to jobfile   \n" >&2; set -x;

		echo "$scriptdir/process_one_fluidigm_specialCases.sh $demultiplexed $R1 $R2 $outputfile $emptyOut $outputdir $runfile" >> $JobFile

	fi ## end if job limit	    


	set +x; echo -e "\n\n\n############  End processing line=$inputline " >&2; set -x;

	
done < $infiles

set +x;
echo -e "\n\n##############################################################################" >&2;  
echo -e "\n\n############   END LOOP1 OVER AMPLICONS                      ###############" >&2;
echo -e "\n\n##############################################################################" >&2; 
set -x; 

set +x;
echo -e "\n\n##############################################################################" >&2;  
echo -e "\n\n############   schedule the last qsub                          ###############" >&2;
echo -e "\n\n##############################################################################" >&2; 
set -x; 

qsub1=$tmpdir/qsub.prepareReads.$JobCounter
echo "#PBS -S /bin/bash" > $qsub1
echo "#PBS -N prepareReads_$JobCounter" >> $qsub1
echo "#PBS -M $email" >> $qsub1
echo "#PBS -m ae" >> $qsub1
echo "#PBS -e $tmpdir/qsub.prepareReads_$JobCounter.er" >> $qsub1
echo "#PBS -o $tmpdir/qsub.prepareReads_$JobCounter.ou" >> $qsub1
echo "#PBS -l nodes=$nodes:ppn=$threads" >> $qsub1
echo "#PBS -q $queue" >> $qsub1
echo "#PBS -l nodes=$nodes:ppn=$threads" >> $qsub1

echo "echo begin execution at \`date\`" >> $qsub1			
cat $JobFile >> $qsub1
echo "echo end   execution at \`date\`" >> $qsub1
`chmod g+r $qsub1 `
jobid=`qsub $qsub1`
echo `date`


echo -e "\n\n##############################################################################" >&2;
echo -e "\n############   ENDS prepare_fluidigmInput_specialCases.sh              #########" >&2;
echo -e "\n##############################################################################\n\n" >&2; 
set -x;
